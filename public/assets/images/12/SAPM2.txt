Why Take SAPM? A Defense of its Relevance to the Real World

What do the following names have in common: Bill Gates, Paul Allen, Steve Jobs, Michael Dell, Larry Ellison, and Mark Zuckerberg? One answer is  their names all contain the letter e. Perhaps a better answer is that each are/were billionaires who dropped out of university. Omniscient readers will know that they were also used in [this blogpost] (http://blog.smartbear.com/software-quality/bid/230121/Math-Nerds-vs-Code-Monkeys-Should-Computer-Science-Classes-Be-More-Practical) to debate the question of whether going to university for computer science is worth it. It falls into the larger debate of experience versus education - does the cost and time of going to university justify the end results, when one could earn comparable experience by working at or even founding a company?

In the case of the above individuals, it didn't. They established or helped raise companies from the ground without university level education. And during this time, I'm willing to guess that the majority of them encountered the problems presented by this course. They made design decisions about their software, they mitigated risk, dealt with unruly team members, and managed large projects. And they did it successfully. 

Software Architecture, Process and Management (SAPM) aims to teach us how to deal with the pitfalls of being a manager. Is it worth taking if individuals can make millions and manage companies without ever stepping foot in the classroom? Surely, such a process is better experienced than taught in school. Can risk management, people skills, and pattern recognition be taught in an environment absent of stress, bosses, and the randomness of life? Even if it can teach us, wouldn't it be better to learn this skills in the field? And how can we guarantee that this course captures the lifeblood of the industry - that the stuff we learn now will still be applicable when we need to use it? 

I would say these arguments miss the strengths of the course. That the lessons put forth are, by nature, extendable. That this course creates the groundwork for a well-rounded understanding - you don't expect to build a manor on swamp ground without the proper foundation. And I would argue that a foundation, whether stemming from experience within the industry or taught in a class, is more or less the same. But I've never been one to sum up an argument when I could address the nitty-gritty hypothetical arguments full on.

A possible argument against SAPM as a class  (one that I made myself when starting this post) is that we have nothing to relate these concepts to. I assume that the majority of us have never led teams at large companies, or worked as managers with an entire software project under our responsibility. Yet we are supposed to understand and apply what we're taught without the ability to reinforce it. You do not give a cycling book to a toddler and expect him, after reading it, to know how to ride a bike. How can we as students be expected to learn from these concepts?

Because its not as a simple as that. 

The toddler isn't being thrown a book without having been on a bicycle. Most of us have been involved in smaller projects where there's been some form of teamwork and leadership needed. Some of us have been through the System Design Project, and while that isn't strictly a large term software development project, it contains elements of things contained in larger projects. Starting with a tricycle and moving towards a bicycle perhaps (though I would contend the two styles of project are too different to be compared as such). 

The examples provided in SAPM are usually self-reflecting. Allan provides us with a design pattern, teammate role or common reason for software failure, and asks us to reflect on our personal experience with the example. These reflections vary from simple code style to the more advanced, like team dynamics. In these reflections, we form the connections about how to employ these things in the real world. And while the understanding might not be fully-fledged, it gives us a foundation to proceed. 

A foundation is good, right? But if its entrenched in academia, doesn't that stir up a host of other problems? The blogpost I mentioned above talks about the lack of computer science in software development, and the lack of software development in computer science. How accurate does academia portray these things? 

Well, I doubt most 'pure' computer science courses would offer a course like SAPM. I could be wrong - we could be covering some mathematical theorems in the next few lectures. But I doubt it. Regardless, there is an argument to be made about how relevant our knowledge is, given how fast computer science progresses.

In the time that it takes to graduate, and rise to the role of a manager, surely there's a risk that the SAPM ideas will become outdated. Moore's law dictates that, every two years, the number of transistors on integrated circuits doubles (increasing both memory and speed of computers). New languages are being designed, and while the trend seems to be shifting towards functional languages, something may come along in the next few years that will change how we view programming entirely (I'm looking at you, quantum computing). With the future changing rapidly, and decidedly non-deterministic, is it worth learning material that could be outdated in a matter of years? 

I believe the versatility of the what is taught will stand the test of time, at least for a few years. These techniques are broad enough to account for different management styles and code bases - they should be able to account for a number of new ideas. Furthermore, just because a new technology has emerged, doesn't mean that the entire industry will shift toward it. The transition time between a new technology and complete integration takes some time - we're still using Java, despite it being over twenty years old. Likewise, the techniques for managing such projects won't likely switch either. For one simple reason - humans. 

While the rate of technology increases, the rate of human complexity remains relatively unchanging (disclaimer: I'm not an evolutionary biologist). The majority of software problems stem from human errors - our inability to estimate risk, our inability to think with perfect logic, and our inability to communicate our ideas properly. Unless technology advances enough to prevent these problems, the majority of the flaws in software design will remain with the human developers. 

And if all design patterns/architectures become outdated, then there's likely been a greater shift in the industry than just a change of paradigms. SAPM isn't the only part of our degree that will be rendered useless. 

So if SAPM seems so crucial to learn, how did the billionaires make it? I would like to put forward that, had any of the above billionaires learned these patterns, they might have avoided small pitfalls during the process of establishing their empires. Both Steve Jobs and Bill Gates were portrayed as vicious managers by their coworkers - they may have lost valuable employees because of it. Facebook's design decisions to use PHP have repeatedly come under fire, and Ellison's attempt to create the network computer resulted in a loss of $175 million. Had these revolutionary men been versed in the methods presented by SAPM, these failures (personal, technical, or business related) could have been avoided, or at least mitigated. This is pure speculation - it is entirely possible that they knew these risks, or that the idea behind the company was too good to screw up. 

And what of the thousands of other companies whose story we do not hear? The companies that failed when their visionary dropped out of college to pursue an idea? They could have failed because they did not manage their risks, or use the right tools, and we would never hear about it. We only hear of the success stories, and not about the 55% of startups that fail. What's worse is that these individuals may not know the precise reason they failed. 

With an education focussing on software management and design, you'll have a better understanding of where you went wrong. Why you failed. Know how to pick up the pieces and rebuild, because you identified the weak player, or the faulty strategy. Know where to refresh your knowledge, or know that you lack it. So will an individual who has taken SAPM be able to recognize and prevent a complete project failure? Maybe, maybe not. It depends on how quickly he can recognize the issues at hand and take the preventive steps. Sometimes, you'll recognize the warnings signs too late. Other times, you won't recognize warning signs at all. 

But we'll have an edge over individuals who skip the higher education process. Consider this: no person enters the field as a manager. It takes time to build up the necessary experience and reputation to achieve such a position. So when we enter the job market, we know what things to look at. Where things go wrong. Rather than just a rush of information, we are given the tools to identify the important bits. And, from the statistics in the lecture, there's a lot of bits where something can go wrong. We know what to pay attention to as we learn, so that when we reach that managerial position, we know how software differs from regular management. And all the relevant experience that would come from ascending the ranks normally would still come your way. 

Wouldn't it be better to enter the field of software development with some words of warning? A caution sign doesn't stop you from wandering off the edge of a cliff, but it's better than no sign. The air raid sirens of the Second World War didn't stop the dropping bombs, but they gave people a chance to get to safety. That's what this course is - a list of warnings and pitfalls. It teaches us what lies in the software world without the risk of failure. Without the risk of being fired. Without the stress of trying to think on your feet. It is a safety net, a tricycle to a bicycle. 

And anyway, it's not like we have a choice now. Most of us have already committed to a university education. The opportunities to learn about the pitfalls of software management are few and far between. Without better opportunities, why not take a course designed to level the playing field when we emerge into the 'real' world of businesses and managers. It's not the same as business, but it's better than not doing anything at all. 


Sources:
http://blog.smartbear.com/software-quality/bid/230121/Math-Nerds-vs-Code-Monkeys-Should-Computer-Science-Classes-Be-More-Practical
http://en.wikipedia.org/wiki/Moore's_law
http://blog.tomevslin.com/2007/05/microsoft_memor.html
http://www.cbsnews.com/8301-505125_162-28247134/microsoft-co-founder-paints-a-brutal-picture-of-bill-gates/
http://www.zdnet.com/blog/facebook/why-facebook-hasnt-ditched-php/9536
http://www.forbes.com/sites/ilyapozin/2012/11/28/how-to-avoid-being-a-startup-failure/
http://www.success.com/articles/765-from-the-archives-larry-ellison
http://www.wired.com/magazine/2009/12/fail_oracle/
http://www.bloomberg.com/news/2012-04-22/software-engineers-will-work-one-day-for-english-majors.html
